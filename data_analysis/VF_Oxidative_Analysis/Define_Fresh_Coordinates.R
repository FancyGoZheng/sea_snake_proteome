seq <- "MERMALYLVAALLIGFPGSSHGALYTLITPAVLRTDTEEQILVEAHGDSTPKQLDIFVHDFPRKQKTLFQTRVDMNPAGGMLVTPTIEIPAKEVSTDSRQNQYVVVQVTGPQVRLEKVVLLSYQSSFLFIQTDKGIYTPGSPVLYRVFSMDHNTSKMNKTVIVEFQTPEGILVSSNSVDLNFFWPYNLPDLVSLGTWRIVAKYEHSPENYTAYFDVRKYVLPSFEVRLQPSEKFFYIDGNENFHVSITARYLYGEEVEGVAFVLFGVKIDDAKKSIPDSLTRIPIIDGDGKATLKRDTFRSRFPNLNELVGHTLYASVTVMTESGSDMVVTEQSGIHIVASPYQIHFTKTPKYFKPGMPYELTVYVTNPDGSPAAHVPVVSEAFHSMGTTLSDGTAKLILNIPLNAQSLPITVRTNHGDLPRERQATKSMTAIAYQTQGGSGNYLHVAITSTEIKPGDNLPVNFNVKGNANSLKQIKYFTYLILNKGKIFKVGRQPRRDGQNLVTMNLHITPDLIPSFRFVAYYQVGNNEIVADSVWVDVKDTCMGTLVVKGDNLIQMPGAAMKIKLEGDPGARVGLVAVDKAVYVLNDKYKISQAKIWDTIEKSDFGCTAGSGQNNLGVFEDAGLALTTSTNLNTKQRSAAKCPQPANRRRRSSVLLLDSNASKAAEFQDQDLRKCCEDVMHENPMGYTCEKRAKYIQEGDACKAAFLECCRYIKGVRDENQRESELFLARDDNEDGFIADSDIISRSDFPKSWLWLTKDLTEEPNSQGISSKTMSFYLRDSITTWVVLAVSFTPTKGICVAEPYEIRVMKVFFIDLQMPYSVVKNEQVEIRAILHNYVNEDIYVRVELLYNPAFCSASTKGQRYRQQFPIKALSSRAVPFVIVPLEQGLHDVEIKASVQEALWSDGVRKKLKVVPEGVQKSIVTIVKLDPRAKGVGGTQLEVIKARKLDDRVPDTEIETKIIIQGDPVAQIIENSIDGSKLNHLIITPSGCGEQNMIRMAAPVIATYYLDTTEQWETLGINRRTEAVNQIVTGYAQQMVYKKADHSYAAFTNRASSSWLTAYVVKVFAMAAKMVAGISHEIICGGVRWLILNRQQPDGAFKENAPVLSGTMQGGIQGAEEEVYLTAFILVALLESKTICNDYVNSLDSSIKKATNYLLKKYEKLQRPYTTALTAYALAAADQLNDDRVLMAASTGRDHWEEYNAHTHNIEGTSYALLALLKMKKFDQTGPIVRWLTDQNFYGETYGQTQATVMAFQALAEYEIQMPTHKDLNLDITIELPDREVPIRYRINYENALLARTVETKLNQDITVTASGDGKATMTILTFYNAQLQEKANVCNKFHLNVSVENIHLNAMGAKGALMLKICTRYLGEVDSTMTIIDISMLTGFLPDAEDLTRLSKGVDRYISRYEVDNNMAQKVAVIIYLNKVSHSEDECLHFKILKHFEVGFIQPGSVKVYSYYNLDEKCTKFYHPDKGTGLLNKICIGNVCRCAGETCSSLNHQERIDVPLQIEKACETNVDYVYKTKLLRIEEQDGNDIYVMDVLEVIKQGTDENPRAKTHQYISQRKCQEALNLKVNDDYLIWGSRSDLLPTKDKISYIITKNTWIERWPHEDECQEEEFQKLCDDFAQFSYTLTEFGCPT
"

# 在比对后，序列中添加了一些“-”字符
aligned_seq <- "MERMA-----LYLVAALLIGFPGSSHGALYTLITPAVLRTDTEEQILVEAHGDSTPKQLDIFVHDFPRKQKTLFQTRVDMNPAGGM-LVTPTIEIPAKEVSTDSRQNQYVVVQVTGPQVRLEKVVLLSYQSSFLFIQTDKGIYTPGSPVLYRVFSMDHNTSKMNKTVIVEFQTPEGILVSSNSVDLN--FFWPYNLPDLVSLGTWRIVAKYEHSP-ENYTAYFDVRKYVLPSFEVRLQPSEKFFYIDGNENFHVSITARYLYGEEVEGVAFVLFGVKIDDAKKSIPDSLTRIPIIDGDGKATLKRDTFRSRFPNLNELVGHTLYASVTVMTESGSDMVVTEQSGIHIVASPYQIHFTKTPKYFKPGMPYELTVYVTNPDGSPAAHVPVVSEAFHSMGTTLSDGTAKLILNIPLNAQSLPITVRTNHGDLPRERQATKSMTAIAYQTQGGSGNYLHVAITSTEIKPGDNLPVNFNVKGNANSLKQIKYFTYLILNKGKIFKVGRQPRRDGQNLVTMNLHITPDLIPSFRFVAYYQVGNNEIVADSVWVDVKDTCMGTLVVKG----DNLIQMPGAAMKIKLEGDPGARVGLVAVDKAVYVLNDKYKISQAKIWDTIEKSDFGCTAGSGQNNLGVFEDAGLALTTSTNLNTKQRSAAKCPQPANRRRRSSVLLLDSNASKAAEFQDQDLRKCCEDVMHENPMGYTCEKRAKYIQEGDACKAAFLECCRYIKGVRDENQRESELFLARDDNEDGFIADSDIISRSDFPKSWLWLTKDLTEEPNSQGISSKTMSFYLRDSITTWVVLAVSFTPTKGICVAEPYEIRVMKVFFIDLQMPYSVVKNEQVEIRAILHNYVNEDIYVRVELLYNPAFCSASTKGQRYRQQFPIKALSSRAVPFVIVPLEQGLHDVEIKASVQEALWSDGVRKKLKVVPEGVQKSIVTIVKLDPRAKGVGGTQLEVIKARKLDDRVPDTEIETKIIIQGDPVAQIIENSIDGSKLNHLIITPSGCGEQNMIRMAAPVIATYYLDTTEQWETLGINRRTEAVNQIVTGYAQQMVYKKADHSYAAFTNRASSSWLTAYVVKVFAMAAKMVAGISHEIICGGVRWLILNRQQPDGAFKENAPVLSGTMQGGIQGAEEEVYLTAFILVALLESKTICNDYVNSLDSSIKKATNYLLKKYEKLQRPYTTALTAYALAAADQLNDDRVLMAASTGRDHWEEYNAHTHNIEGTSYALLALLKMKKFDQTGPIVRWLTDQNFYGETYGQTQATVMAFQALAEYEIQMPTHKDLNLDITIELPDREVPIRYRINYENALLARTVETKLNQDITVTASGDGKATMTILTFYNAQLQEKANVCNKFHLNVSVENIHLN---AMGAKGALMLKICTRYLGEVDSTMTIIDISMLTGFLPDAEDLTRLSKGVDRYISRYEVDNNMAQKVAVIIYLNKVSHSEDECLHFKILKHFEVGFIQPGSVKVYSYYNLDEKCTKFYHPDKGTGLLNKICIGNVCRCAGETCSSLNHQERIDVPLQIEKACETNVDYVYKTKLLRIEEQDGNDIYVMDVLEVIKQGTDENPRAKTHQYISQRKCQEALNLKVNDDYLIWGSRSDLLPTKDKISYIITKNTWIERWPHEDECQEEEFQKLCDDFAQFSYTLTEFGCPT
"

# 计算原始坐标和新坐标之间的关系
calc_new_range <- function(x, old_start, old_end) {
  # 找到所有干扰字符“-”在字符串中的位置
  dash_locs <- str_locate_all(x, "-")[[1]][,1]
  
  # 计算原先字母子集对应的新坐标范围
  new_start <- old_start + sum(dash_locs < old_start)
  new_end <- old_end + sum(dash_locs <= old_end)
  
  # 返回新坐标范围
  return(c(new_start, new_end))
}


## 示例用法
new_range <- calc_new_range(aligned_seq, old_start, old_end)
x <- aligned_seq




#  1.拿到 对应位置区段新的坐标范围。 2. 然后获得自己序列比对后的新的坐标。3. 因为自己序列的坐标和目的序列的坐标在比对后是一样的，所以直接自己比对后修饰位点的新坐标落在什么结构的坐标范围内
#654-732
#677-712
#736-747
#985-1263
#1190-1253
#1497-1640


## 读入结构坐标数据

pos <- read.delim("input/position.txt")


#### 开始循环计算

output <- data.frame(matrix(ncol = 5, nrow = 0))



for (i in 1:length(pos$struction))
{
  old_start <- pos$start[i] ###赋值给函数的起始位点
  old_end <- pos$end[i]  ### 取出对应值赋值给函数的结束位点
  out <- calc_new_range(aligned_seq, old_start, old_end)  # 通过函数来计算对应的新的起始和结束位点
  temp<- c(pos$struction[i],pos$start[i],pos$end[i],out   ) # 将结果放在一个向量中
  output<- rbind(output, temp) ## 合并到结果数据框中
  
  
}

colnames(output) <- c("struction","old_start","old_end","new_start","new_end")



vf_alig_seq <- c("FPRKTNSGDVLFFFCS-------------YTLITPGVLRTDTEEQILVEAHGDSAPKQPVISVHDFPRRQKTLFQARVDMNPAGGMLVTPTIKIPAKELNKDSRQNQYVVVKVSGLPIELEKVVLLSYQSGFVFIQTDKGIYTPGSPVRYRVFSMDYNMHRMDKTVIVEFQTPEGVVVSSNPVNPSSVLIRPYNLPELVSFGTWKAVAKYEHSPEESYTAYFDVREY------VRLQPSDKFLYIDGNKNFHVSITARYLYGKKVEGVAFVLFGVKIDDAKKSIPDSLTRIPIIDGDGEAILKRDTLRSRFQNLNQLVGHTLYASVTVMTESGSDMVVTEQSGIHIVTSPYQIYFTKTPKYFKPGMPYELTVYVTNPDGSPAANVPVVSEAIHSEGTTLSDGTAKLILNTLLNTQNLLITVRTNHRDLPRERQATKSMTATAYQTQGGSGNYLHVAITSTEIKAGDNLPVNFNVRGNANSLNQIKYFTYLILTKGKIFKVGRQPKGEGQNLVTMNLRITPDLIPSFRFVAYYQVGNNEIVADSVWVDVKDTCMGTLVVKGASSRDNRIQKPGGAMKIKLEGDPGARVGLVAVDKAVYVLNDKYKISQAKIWDTIEKSDFGCTAGGGQNNLGVFEDAGLALTTSTNLNTKQRSVATCPQPTNRRRRSSVLLLDSKASKAAQFQDQNLRKCCEDGMHENPMGYTCEKRAKYIQEGDACKAAFLECCHYIKGIRDENQRETELFLARSDFEDDFFGEDNIISRSDFPESWLWLTEDLKEPPNNQGISSKTLSFYLRDSITTWEVLAVSIAPTKGICVAEPYEITVMKDFFIDLRVPYSVVKNEQVEIRAILYNYADEDINVRVELLYNPAFCSASTEGQRYRVQVPIRALSSWAVPFVIVPLQQGLHDVEVKASVQGLLVSDGVKKKLKVVPEGERKNIVTVIELDPSVKGVGGTQEQTVIANKLDDKVPETEIETKISVLGDPVAQIIENSIDGSKLKHLIITPSGCGEQNMITMTPSVIATYYLDATGQWENLGVDRRTEAVKQIMKGYAQQMVYKKADHSYAAFPN--------PYVVKVFAMAAKTVKDIKHDIICGGVKWLILNRQQPDGVFKENAPVIHGEMLGGTKGAEPEVSLTAFILVALLESRSICNEHINILDSSINKAIDYLLKKYEKLQRPYTTALTAYALAAAERLNDDRVLMAASTGRNRWEEYNARTYNIEGTSYALLALLKMKKFAEAGPVVKWLIDQKYYGGTYGQTQATVMVFQALAEYEIQMPTHKDLNLHISINLPEREVPLSYSINYGNALVARTAETKLNEDFTVSASGDGKATMTILTVYNAQLREDANICNKFHLDVSVENAQLNSKQAKGAKGTLRLKICTRYLGEIDSTMTIIDVSMLTGFLPDAEDLTRLSKGVDRYISKFEIDNDIVQKGTVVIYLDKLSHSEVECLHFKIHKHFE--------------------CTKFYHPDKGTGLLNKICHGNICRCAEETCSLLNQQKKIDLQLRIQKACAPNVDYVYKAKLLRIEEKDGNDIYVMDVLEVIKGGTDRNPQAKARQYVSQRKCQEALNLKLNNDYLIWGLSSDLWPMKNDFSYLITKNTWIERWPNEDECQDEEFQKLCDDFTQLSNTLTIFGCPT-
")
    

vfpos <- read.delim("input/vf_position.txt")
vfoutput <- data.frame(matrix(ncol = 5, nrow = 0))

for (i in 1:length(vfpos$struction))
{
  old_start <- vfpos$start[i] ###赋值给函数的起始位点
  old_end <- vfpos$end[i]  ### 取出对应值赋值给函数的结束位点
  out <- calc_new_range(vf_alig_seq, old_start, old_end)  # 通过函数来计算对应的新的起始和结束位点
  temp<- c(vfpos$struction[i],vfpos$start[i],vfpos$end[i],out   ) # 将结果放在一个向量中
  vfoutput<- rbind(vfoutput, temp) ## 合并到结果数据框中
}

colnames(vfoutput) <- c("struction","old_start","old_end","new_start","new_end")
## 结果变量  vfoutput，output

write.xlsx(vfoutput,"output/vf比对后的修饰位点信息.xlsx",sheetName = "Sheet1",row.names = F)




### 寻找每个结合位点所在的结构区间
output <- output %>% mutate_at(c(2: 5), as.numeric)


find_out <- data.frame()
for (i in vfoutput$new_start) {
  i <- as.numeric(i)
  # 在第二个数据框中找到它所在的范围
  result <- output[output$new_start <= i & output$new_end >= i,]
  # 输出结果
  modi_type <- vfoutput[vfoutput$new_start == i,1]
  result1 <- cbind(result,i,modi_type) ## 得到对应的结构和区间，通过列合并添加该坐标 
  find_out <- rbind(find_out,result1) ## 将结果通过循环行合并起来
}

## 结果放在find_out 变量中，得到对应位置和对应的结构

write.xlsx(find_out,"vf——443——Oxidation_Site_Structural_Region.xlsx",sheetName = "Sheet1")




result1 <- cbind(result,i,modi_type)



###########   拿到二级结构后和其去比     ############# 
str_pos <- read.delim("input/2_Secondary_Structure_Coordinates.txt")

str_output <- data.frame(matrix(ncol = 5, nrow = 0))



for (i in 1:length(str_pos$struction))
{
  old_start <- str_pos$start[i] ###赋值给函数的起始位点
  old_end <- str_pos$end[i]  ### 取出对应值赋值给函数的结束位点
  out <- calc_new_range(aligned_seq, old_start, old_end)  # 通过函数来计算对应的新的起始和结束位点
  temp<- c(str_pos$struction[i],str_pos$start[i],str_pos$end[i],out   ) # 将结果放在一个向量中
  str_output<- rbind(str_output, temp) ## 合并到结果数据框中
  
  
}

colnames(str_output) <- c("struction","old_start","old_end","new_start","new_end")

####  此处得到二级结构坐标的新坐标  变量名称：str_output




## 接下来将修饰位点与结构位点比较
str_find_out <- data.frame()


####将uniport上vf分子的二级结构的坐标改为数值格式，不然默认为字符格式，无法比较修饰位点是否在此区间
str_output[,2:5] <- lapply(str_output[,2:5], as.numeric)





###

for (i in vfoutput$new_start) {
  i <- as.numeric(i)
  # 在第二个数据框中找到它所在的范围
  result <- str_output[str_output$new_start <= i & str_output$new_end >= i,]
  # 输出结果
  # 加了个判断语句，查找结果的变量result为0时，则跳过结果输出，避免报错
  
  if (dim(result)[1] >0 ) 
  {
    modi_type <- vfoutput[vfoutput$new_start == i,1]
    result1 <- cbind(result,i,modi_type) ## 得到对应的结构和区间，通过列合并添加该坐标 
    str_find_out <- rbind(str_find_out,result1) ## 将结果通过循环行合并起来
  }
  
}


#########到这里二级结构的查找完毕， 结果变量：str_find_out


#dir.create("output")
write.xlsx(x=str_find_out,"output/str_find_out.xlsx",sheetName = "Sheet1",row.names = F)




